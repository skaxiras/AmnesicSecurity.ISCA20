\begin{verbatim}
    * Benchmarks 
        * Justification for non-parallel?
    * Simulation framework 
        * Microarchitecture for recomputation
            * Recomputation buffers
                Size, configuration, ...
            * Model for potential ISA extensions
        * Energy model
\end{verbatim}

\begin{table}
  \centering
  \caption{The simulated system parameters.}
  \label{table:sim-params}
  \begin{tabular}{ l | l }
    \hline
    Parameter & Value\\
    \hline
    Technology node                           & 22nm \\
    Processor type                            & out-of-order x86 CPU \\
    Processor frequency                       & 3.4GHz \\
    Issue / Execute / Commit width            & 8 \\
    Cache line size                           & 64 bytes \\
    L1 private cache size                     & 32KiB, 8-way \\
    L1 access latency                         & 2 cycles \\
    L2 shared cache size                      & 1MiB, 16-way \\
    L2 access latency                         & 20 cycles \\
    Value predictor                           & VTAGE \\
    Value predictor size                      & 13 components $\times$ 128 entries \\
    \hline
  \end{tabular}
\end{table}

We use the Pin tool developed by Akturk and Karpuzcu~\cite{} for AMNESIAC to generate the slices for the applications.
We then feed the generated slices to a Gem5 simulator where the shadows, Delay-on-Miss, and VP have been implemented as described in the Delay-on-Miss work by Sakalis et al~\cite{}. In Gem5, we first fast-forward through the first one billion instructions of the application and then simulate in detail for another billion. We also use McPAT~\cite{} with CACTI~\cite{}, as well as the dynamic DRAM energy provided by Gem5, to calculate the energy usage of the system. The configuration parameters can be seen in~\autoref{table:sim-params}.
We evaluate our proposal of combining Delay-on-Miss with \recomp~  and compare with the a baseline Delay-on-Miss version (no VP or \recomp) as well as a Delay-on-Miss with VP. Finally, we also present what would happen if ideal, Oracle VP or \recomp~ were used. Both Oracles can predict 100\% of the shadowed L1 misses, the difference is that the VP Oracle still needs to send out validations. For the RC Oracle, we assume that each slice consists of ten integer operations, five floating point operations, and takes ten cycles to be computed. Given the average latency we have observed(\autoref{fig:rc-latency}), these numbers are not unrealistic.
We evaluate all these different versions using the SPEC2006 benchmark suite~\cite{}, with the reference inputs.

\noindent \textbf{RSlice Profiling:} 
The RSlice \textcolor{red}{(Check defintion of RSlice in text)} profiling entails running AMNESIAC within the region of interest, defined by skipping and running the PinTool for specific number of instructions, generating all the possible RSlices within that region of interest. Having a RSlice corresponding to a load instruction means this load instruction can be replaced by the sequence of instructions defined by the corresponding RSlice. A RSlice generation begins with a load instruction at the root of the slice. Tracking the producer-consumer relationship between the corresponding load value (as the consumer), the producer instruction(s) responsible for generating that load value are added to the corresponding RSlice. The input operands for the producer instructions are generated by replacing the corresponding operands with the respective producer instructions, recursively, until a store is encountered at the root load value address. All the intermediate loads encountered during RSlice build-up is replaced by the corresponding producer instructions- leaving no load and conditional instructions in the generated RSlice.    
