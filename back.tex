\subsection{Threat Model}
\label{sec:threat}
%\input{threat} We do not need more sub-levels do we?
{ \color{red} [FIXME: Probably discuss after the shadows?] }

\subsection{Speculation Shadows} 
Sakalis et al. introduced the concept of \textbf{\emph{Speculative Shadows}} to reason about the earliest time an instruction becomes non-speculative and is considered safe to execute regardless of its effects on $\mu$-architectural state~\cite{sakalis2019efficient}.
Instructions that can cast speculative shadows on younger instructions in the dynamic instruction stream are known as \textbf{speculation primitives}.
Prior work identified the following types of shadows: \emph{E-Shadows} are cast by any instruction that can cause an \textbf{exception}; 
\emph{C-Shadows} are cast by \textbf{control} instructions, such as branches and jumps, when either the branch condition or the target address are unknown or have been predicted but not yet verified; \emph{D-Shadows} are cast by potential \textbf{data dependencies} through stores with unresolved addresses (read-after-write dependencies); \emph{M-shadows} are cast by \emph{speculatively executed memory accesses} that speculatively violate the ordering rules of a memory model (e.g., total store order---TSO); and \emph{V-shadows} that are cast by value-predicted loads~\cite{sakalis2019efficient}.

\subsection{Delay on Miss and Value Prediction}
\label{sec:dom-vp}
%\input{dom-vp} We do not need more sub-levels do we?
Delay-on-miss and VP. Delay-on-miss preserves some MLP. VP on the other hand destroys MLP.

\paragraph{Why is Delay on Miss so good to begin with}
Explain that we gain a lot out of intra-cache-line MLP.
If possible give a breakdown of intra-cache-line MLP vs. inter-cache-line MLP.
We lose the second and that's what we experience as performance loss.

\paragraph{Why VP cannot offer much on top}
VP needs to be validated. In order! Non-speculative load-load reordering cannot hep here as we are bound by a new speculation: VP-speculation (VP-Shadow). This prevents any MLP for the validation phase. Whatever VP wins in latency (pre-executing load and dependent instructions if correct), looses later in MLP. Result: limited.

\subsection{Data Recomputation}
\label{sec:recmp}
%\input{recmp} We do not need more sub-levels do we?
Proposed as a way to trade in-core computation (cheap in energy) to data movement (expensive in energy) and at the same time perform better when the latency to re-compute is less than the latency to move data throughout the memory hierarchy.
\paragraph{Why RC can offer beyond VP}
Benefits in both latency and MLP: Latency: if recomputation is faster than a miss. MLP: No need to validate, hence does not impose any further restrictions on MLP, hence better performance. Energy: additional benefits in energy if recomputation needs less energy than data movement. Limitation: cannot do too much of it in practice.



 