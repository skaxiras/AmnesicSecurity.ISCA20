{\color{red} Stefanos: I've got this}
\begin{verbatim}
    1 Making speculation "invisible"
      Can we come up w/ a taxonomy?
        Coverage, complexity, ...?
    2 Cache side channels 
        [Omit?]
    3 Other related work?
        [Omit?]
\end{verbatim}

%\paragraph{First response techniques: delay, hide\&replay, or cleanup?}
%\paragraph
\noindent \textbf{First response techniques: delay, hide\&replay, or cleanup?}
The architecture community proposed a number of techniques to prevent \emph{disclosure gadgets} from revealing secrets. The techniques fall in one of the following three broad categories shown below but each individual proposal has different assumptions as to the threat model (type of speculation shadows covered) and prevention of information leakage (disclosure gadgets).
\squishlist
\item{\textbf{Hide\&Replay:}} During speculation, perform memory accesses in a manner that does not perturb any $\mu$--architectural state in the memory system (except DRAM row buffers which is unavoidable); subsequently, perform a replay of the access (when it becomes non-speculative) to affect the correct changes in the $\mu$-architectural state. \emph{Invisispec} (Yan et al.)~\cite{yan_invisispec:MICRO2018} and \emph{Ghost loads} (Sakalis et al.)~\cite{sakalis+:CF2019ghost} were the first such proposals. 
Hide\&Replay techniques, as the first to be proposed, showed a significant cost in performance (and a moderate implementation cost). They only protect against information leaks via the memory hierarchy (and not even all of it, as DRAM leaks are possible~\cite{pessl2016drama}). On the other hand, Hide\&Replay techniques were designed to protect against attacks on any possible speculation primitive, i.e., cover all the speculative shadows mentioned above. 
\item{\textbf{Delay:}} Delay speculative changes in $\mu$-architectural state until execution is non-speculative. Sakalis et al. proposed to delay loads that miss in the L1 (\emph{Delay on miss}) until they are non-speculative~\cite{sakalis+:ISCA2019vp}. This delays any $\mu$-state change in the memory hierarchy. A different form of delay (\emph{NDA}) proposed by Weisse et al., is to prevent speculative data propagation by delaying \emph{dependent instructions} from executing with speculative inputs~\cite{weisse2019nda}. Delay-on-miss protects against \emph{all} speculative shadows (i.e., any possible ``Speculation Primitive'') but delays only changes in the memory hierarchy (including DRAM). Subsequent work, that delays speculative propagation of data~\cite{weisse2019nda} (NDA, Michigan), protects against any $\mu$-architectural state changes (i.e., a much larger gamut of ``disclosure gadgets'' than just the memory hierarchy) but responding only to C-Shadows, i.e., control speculation primitives.
\item{\textbf{Cleanup:}} Perform a speculative change in $\mu$-architectural state but then \emph{undo} if speculation is squashed. In the first such proposal, \emph{CleanupSpec}, by Sailshwar et al.~\cite{saileshwar2019cleanupspec}, the undo is expensive so its application is restricted to the L1 cache. The rest of the memory hierarchy (L2, LLC, and coherence Directory) is assumed to be protected in other ways, including randomization and delaying of coherence state changes, but DRAM row buffers still remain a security hole.
Cleanup techniques only protect the L1, assuming--at a cost---that the rest of the hierarchy (excluding DRAM) is protected otherwise~\cite{saileshwar2019cleanupspec}. 
\squishend
{\color{red} It is obvious that at this point no direct comparison is possible but we make an effort to compare for the same threat model where possible.}



