\begin{verbatim}
    1 Problem statement: 
        Spectre, Meltdown, ++?
    2 Summary of recent arch. solutions
        Making speculative data invisible
        2.1 Overhead & complexity per se
        2.2 Limitations
        2.3 Coverage
    3 Proposed solution: 
        Recompute speculative load values
        3.1 Overhead & complexity 
            Put into perspective
        3.2 Limitations 
        3.3 Coverage
        3.4 Putting it all together:
            * Orthogonal to which, 
                alternative to what, ... wrt 2
            * Open new vulnerabilities?
\end{verbatim}


The instruction set architecture (ISA) defines the functional aspects of a computer system, in particular the hardware/software interface, without much concern for specifying \emph{non-functional}, \emph{implementation-dependent} aspects (e.g., timing, energy, or other potential signals emanated by the execution of a program on an actual computer system). This provides a tremendous felexobility with respect to the implementation of an ISA. However, exclusion of non-functional aspects at the architectural level, opens a wide array of \emph{side channels where information can leak covertly}. Side-channel attacks come in many different forms exploiting all kinds of information stored in ---\emph{what should normally be software-invisible}--- microarchitectural structures. Attacks have been demonstrated using a wide variety of measurements, including electromagnetic emissions~\cite{agrawal2002side}, energy consumption~\cite{kocher1999differential}, even input/output devices\cite{genkin2014rsa,ferrigno2008aes,carmon2017photonic}. The most common, practical (and first to be discovered~\cite{bernstein2005cache}) type of attack is based on \emph{timing}. More specifically, timing attacks infer secrets by measuring time differences resulting from microarchitectural optimizations.

The classic example of a timing side channel are processor caches which store the address and value of recently accessed memory locations. Accesses to cached memory locations are faster, revealing information about which addresses were or were not recently accessed~\cite{yarom_flush+_2014,liu15llc,irazoqui_cross_2016}. Other types of side channels are also possible involving a variety of microarchitectural state (e.g., coherence states, directories, DRAM row buffers) 
and various attacks have been demonstrated in practice~\cite{}.

\emph{Speculation}, one of the fundamental techniques for achieving high
performance, proved to be a significant security hole, leaving the door wide
open for side-channel attacks to ``see'' protected data~\cite{kocher_spectre_2018,lipp_meltdown_2018}.
As far as the instruction set architecture (ISA) and the target program are
concerned, leaking information across a covert timing side-channel (based on microarchitectural state and structures) is not illegal
because it does not violate the functional, architectural behavior of the program.
But \emph{speculative} side channel attacks reveal secret information during \emph{misspeculations}, 
i.e., \emph{discarded execution that is not a part of the normal execution of a program}.
The stealthy nature of a speculative side-channel attack is based on
\emph{microarchitectural} state being changed by misspeculation even when the \emph{architectural}
state is not.

\noindent \textbf{First response techniques: hide\&replay, delay, or cleanup?}
The architecture community responded to the speculative attack threat by proposing a number of techniques to prevent speculative execution from revealing secrets. These techniques fall into one of the following three broad categories:
\squishlist
\item{\textbf{Hide\&Replay:}} During speculation, perform memory accesses in a manner that does not perturb any microarchitectural state ($\mu$-state) in the memory system (except DRAM row buffers which is unavoidable); subsequently, perform a replay of the access (when it becomes non-speculative) to affect the correct changes in the $\mu$-state~\cite{yan_invisispec:MICRO2018,sakalis2019ghost}. 
\item{\textbf{Delay:}} Delay speculative changes in $\mu$-state until execution is non-speculative. Sakalis et al. proposed to delay loads that miss in the L1 (\emph{Delay on miss}) until they are non-speculative~\cite{sakalis2019efficient}. This delays any $\mu$-state change in the memory hierarchy. A different form of delay (\emph{NDA}) proposed by Weisse et al., is to prevent speculative data propagation by delaying \emph{dependent instructions} from executing with speculative inputs~\cite{weisse2019nda}.
\item{\textbf{Cleanup:}} Perform a speculative change in $\mu$-state but then \emph{undo} if speculation is squashed~\cite{saileshwar2019cleanupspec}.
\squishend

Unfortunately, all of these were proposed under different thread models and different assumptions about the security mechanisms throughout the system so their contribution to increased security and their cost (in performance, area,, energy) are \emph{not directly comparable}. Section \ref{sec:related} provides an extensive discussion. Our own tests show that when some of the techniques (e.g., Delay-on-miss and NDA) are examined under the same conditions (threat models) yield comparable results, e.g., in performance, but significantly more work is required to be able to arrive at safe conclusions regarding the whole of the area.

In this work we assume a threat model that includes all types of \emph{speculative shadows} but focuses on timing side-channels in the whole of the memory system. This corresponds to the threat model of Delay-on-miss. Other threat models are beyond the scope of this paper but will be considered in future work. %Threat model: ALL SHADOWS/ALL HIERARCHY. This is the threat model for Delay-on-miss, but no other proposed technique (NDA:  C-SHADOWS/ALL-$\mu$-state, Invisispec: ALL-SHADOWS/ALL-HIERARCHY-MINUS-DRAM, CleanupSpec ALL-SHADOWS/L1)







